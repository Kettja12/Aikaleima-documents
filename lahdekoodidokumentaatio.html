<html>
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/app.css">
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <script src="js/popper.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="lahdedokumentaatio.css">
    <!-- Prism.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
    <style>
        pre[class*="language-"] {
            display: block;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: .375rem; /* Bootstrap border-radius */
        }
    </style>
</head>
<body>
<h2>Lähdekoodidokumentaatio</h2>
<div class="alert alert-info" role="alert">
  <strong>Huom!</strong> Tämän dokumentaation kuvaama lähdekoodi ei ole julkisesti saatavilla. Pääset tutustumaan siihen ottamalla yhteyttä projektin omistajaan <a href="https://github.com/Kettja12" target="_blank" rel="noopener noreferrer" class="alert-link">GitHub-profiilin</a> kautta.
</div>
<p>
	Tämän dokumentaation painopiste on lähdekoodissa. Mikäli <a href="https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor">Blazor</a> ei ole tuttu, paras tietolähde sen kotisivujen jälkeen on YouTube.
	Paras ohjelmointiympäristö on mielestäni ilmainen <a href="https://visualstudio.microsoft.com/vs/community/">Visual Studio Community</a>,
	ei ainoastaan Blazor-sovellusten, vaan yleisemminkin <a href="https://dotnet.microsoft.com/en-us/">.NET</a>-sovellusten rakentamiseen.
</p>
<p>
    Sovelluksen suunnittelumalli on modulaarinen monoliitti. Jos termi ei ole tuttu, kyseessä on arkkitehtuurimalli, jossa sovellus on jaettu useisiin itsenäisiin moduuleihin, mutta kaikki moduulit toimivat yhdessä yhtenä kokonaisuutena.
    Tämä malli tarjoaa etuja, kuten helpomman ylläpidon ja kehityksen, koska moduulit voidaan kehittää ja testata erikseen, mutta ne jakavat saman sovellusympäristön.
    Mitä se sitten tarkoittaa? Se tarkoittaa, että sovelluksen eri osat on jaettu selkeisiin osioihin, joita kutsutaan myös moduuleiksi, ja jotka käännetään yhdeksi kokonaisuudeksi. Ohjelmistokehityksen trendit ovat viime vuosina suosineet mikropalveluarkkitehtuuria, jossa sovellus jaetaan pieniin, itsenäisiin palveluihin.
    Modulaarinen monoliitti tarjoaa kuitenkin tasapainon monoliittisen ja mikropalveluarkkitehtuurin välillä, jolloin kehittäjät voivat hyödyntää molempien mallien etuja.
</p>

<div class="diagram-container">
    <div class="client-column">
        <div class="diagram-outer-box">
            <div class="label">Selain ja verkkosivu</div>
            <div class="diagram-box">
                Käyttöliittymä
            </div>
        </div>
        <div class="diagram-box" style="width: 200px; margin-top: 50px;">
            Android/Windows client
        </div>
    </div>

    <div class="diagram-outer-box" style="width: 420px; min-height: 240px;">
        <div class="label">Palvelin</div>
        <div class="inner-flex-container">
            <div class="diagram-box" style="width: 200px; min-height: 200px;">
                Blazor server proosessi
            </div>
            <div class="diagram-box">
                Tietokanta
            </div>
        </div>
    </div>
    <div class="arrow-connector">
        <div class="arrow-label-right">click, jne...</div>
        <div class="arrow-label-left">DOM-päivitykset</div>
        <div class="arrow-text">SignalR</div>
        <div class="arrow right"></div>
        <div class="arrow left"></div>
    </div>
    <div class="api-arrow-connector">
        <div class="api-arrow-text">api-rajapinta</div>
        <div class="api-arrow right"></div>
        <div class="api-arrow left"></div>
    </div>

</div>
<article>
    <h2>Sovelluksen rakenne</h2>
    <p>
        Lähdekoodissa sovellus koostuu seuraavista moduuleista.
    </p>
    <h3>Sovellus ydintoiminnot</h3>
    <p>
        Ydintoiminnot hoitavat sovelluksen käynnistyksen, konfiguroinnin ja HTTP-pyyntöjen käsittelyn.
        Ne vastaavat myös palveluista, eri näkymien renderöinnistä ja käyttäjän syötteiden välittämisestä käyttöliittymäkomponenteille.
        <a href="https://github.com/Kettja12/aikajana-ssr/blob/e072c1b609c987aa242d944edb39cef923bf0fcd/Program.cs?plain=1#L5C1-L5C50" class="btn btn-outline-secondary btn-sm" target="_blank" rel="noopener noreferrer">Katso Program.cs GitHubissa</a>
        <pre><code class="language-csharp escape-needed"><!--
var builder = WebApplication.CreateBuilder(args);
var sqlitedbPath = builder.Configuration.GetConnectionString("SQLiteConnection");
builder.Services.AddDbContextFactory<AppDbContext>((sp, options) => {
    options.UseSqlite(sqlitedbPath);
    options.EnableSensitiveDataLogging();
});

//builder.Services.AddExceptionHandler<GlobalExceptionHandler>();

// Add services to the container.
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

builder.Services.AddScoped<Services>();
builder.Services.AddScoped<IndexedDbAccessor>();
builder.Services.AddScoped<State>();
builder.Services.Configure<ForwardedHeadersOptions>(options =>
{
    options.ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto;
    options.KnownProxies.Add(IPAddress.Parse("127.0.0.1")); // add nginx IP(s)
});
builder.Services.AddLocalization();
var app = builder.Build();

app.UseRequestLocalization("fi-FI");
// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseForwardedHeaders();
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}
else
{
    app.UseForwardedHeaders();
}
app.Use(async (context, next) =>
{
    if (context.Request.Headers.TryGetValue("X-Forwarded-Prefix", out var prefix) &&
        !string.IsNullOrWhiteSpace(prefix))
    {
        var p = prefix.ToString();
        if (!p.StartsWith('/')) p = "/" + p;
        context.Request.PathBase = new PathString(p.TrimEnd('/'));
    }
    await next();
});

app.MapRoutes();
app.UseStatusCodePagesWithReExecute("/not-found", createScopeForStatusCodePages: true);

//app.UseHttpsRedirection();

app.UseAntiforgery();

app.MapStaticAssets();

app.MapRazorComponents<App>()
    .AddInteractiveServerRenderMode();

app.Run();

        --></code></pre>
    </p>
    <h3>Käyttöliitymä komponentit</h3>
    <p>
        Komponentit löytyvät lähdekoodista 'Components'-kansiosta, ja ne on jaettu kolmeen pääryhmään: Common, Layout ja Pages.
        'Pages'-kansiossa sijaitsevat sovelluksen eri näkymät (esim. users.razor). Näkymällä voi olla erillinen taustakooditiedosto (users.razor.cs), joka käsittelee näytön toiminnallisuuden.
        Toiminnallisuus voi kuitenkin sijaita myös suoraan näkymätiedostossa `@code`-lohkossa, jos koodia on vähän. Tällöin on helpompaa hahmottaa HTML-rakenne ja siihen liittyvät toiminnot samanaikaisesti.
        Jokainen näkymä luo latautuessaan itseään vastaavan model-luokan Domain-moduulista ja yleensä sijoittaa sen State-moduuliin. Käyttöliittymän komponentit käyttävät State-moduulia ja sen sisältämiä luokkia
        näytettävien tietojen esittämiseen ja syötteiden käsittelyyn.
        <pre><code id="razor-code-block" class="language-cshtml escape-needed"><!--
            <Message Refresh="state.Refresh" />
<div class="mb-3">
	<button type="button" @onclick="state.UserModel.AddUser" class="btn btn-primary">Lisää käyttäjä</button>
</div>
<div class="mb-3">
	<label for="name" class="form-label">Käyttäjän nimi</label>
	<input type="text" class="form-control" id="name" @bind="state.UserModel.User.Name">
</div>
<div class="mb-3">
	<label class="form-label">Rekisteröintiavaimen luonti</label>

	@if (state.UserModel.User.Token.Length == 6)
	{
		<div class="mb-3">
			<label for="Token" class="form-label">Rekisteröintiavain</label>
			<span>@state.UserModel.User.Token</span>
		</div>
	}
	<div class="form-check mb-3">
		<input class="form-check-input" type="checkbox" name="pincode" id="pincode"
			   @bind="state.UserModel.User.Pincode">
		<label class="form-check-label" for="pincode">
			Pin-koodi käytössä
		</label>
	</div>


	@if (state.UserModel.User.Id != 0)
	{
		@if (state.UserModel.User.Activated)
		{
			<div class="form-check mb-3">
				<input class="form-check-input" type="checkbox" name="activated" id="activated"
					   @bind="state.UserModel.User.Activated" readonly>
				<label class="form-check-label" for="activated">
					Aktivoitu
				</label>
			</div>
		}
		<button type="button" @onclick="state.UserModel.SendRegistrationKey" class="btn btn-primary">
			Luo uusi rekisteröintiavain
		</button>
	}
</div>
<button type="button" @onclick="SaveUser" class="btn btn-primary">Tallenna käyttäjä</button>
@code {
	[Inject] State state { get; set; } = default!;

	[Parameter] public int UserId { get; set; }
	[Parameter] public EventCallback<int> UserChangedAsync { get; set; }

	protected override async Task OnParametersSetAsync()
	{
		await state.UserModel.SelectUserAsync(UserId);
	}
	public async Task SaveUser()
	{
		await state.UserModel.SaveUser();
		if (UserId != state.UserModel.User.Id)
		{
			await UserChangedAsync.InvokeAsync(state.UserModel.User.Id);
		}
	}
	public async Task SendRegistrationKey()
	{
		await state.UserModel.SendRegistrationKey();
	}

    --></code></pre>
    </p>
    <h3>Domain</h3>
    <p>
        Domain-moduuli sisältää jokaista näkymää vastaavan luokan (esim. `Users.model`). Model-luokka sisältää kaiken näytön tarvitseman toimintalogiikan ja metodit, jotka hakevat tiedot Repository-moduulista.
        Model-luokka on tietoinen State-luokasta ja pääsee sen kautta tarpeen mukaan käsiksi muihin tilan model-luokkiin. Näin toteutetaan esimerkiksi tilanne, jossa `DeviceModel` tarvitsee leimauslajeja: se voi kutsua
        `state.StampcategoryModel`-luokan metodeja, kuten `state.StampcategoryModel.SelectStampcategory(2345);`.
        Joka on tässä tapauksessa seuraavan kaltainen metodi:
        <pre><code class="language-csharp">
            public async Task SelectStampcategoryAsync(int id)
            {
                IdRequest request = new(state.LoginToken, id);
                Stampcategory = await state.Services.StampcategoryAsync(request);
            }
        </code></pre>
        Esimerkki on hieman yksinkertaistettu, koska `StampCategoryModel`-luokassa on oletuksena vain yksi `Stampcategory`-ominaisuus.
        Tämän avulla voidaan kuitenkin toteuttaa välimuisti (cache), jolloin tietoa ei tarvitse hakea uudestaan, jos se on jo muistissa. Tämä toimii, mikäli sama arvo (ns. `CurrentStampcategory`) on sopiva kaikille tilan moduuleille.
        Parempi implementaatio olisi palauttaa arvo:
        <pre><code class="language-csharp escape-needed"><!--
            public async Task<Stampcategory> SelectStampcategoryAsync(int id)
            {
                IdRequest request = new(state.LoginToken, id);
                return await state.Services.StampcategoryAsync(request);
            }
        --></code></pre>
            
    </p>
    <h3>Tila</h3>
    <p>
        Tila (State) on luokka, joka hoitaa sovelluksen tilanhallinnan. Tila on passiivinen, ja jokaisella käyttäjällä on oma, erillinen tilansa.
    </p>
        
    </p>
    <h3>Repository</h3>
    <p>
        Repository on DLL-moduuli, joka hoitaa tietokantaoperaatiot.
        Repository-moduulin rajapinta koostuu kolmesta osasta: pyynnöistä (request), vastauksista (response) ja palveluista (services).
        Repositoryn `Services`-luokka toteuttaa kaikki palvelut, ja sen metodeja kutsutaan muualta koodista.
        Palvelut ovat funktioita, jotka suorittavat tietyn toiminnon. `Request`-parametrilla kerrotaan toiminnolle tarvittavat tiedot, ja `Response` palauttaa toiminnon tuloksen.
    </p>
    <h3>Shared</h3>
    <p>
        Shared on DLL-moduuli, joka sisältää jaetut luokat, kuten API-rajapinnan data-mallit.
    </p>
    <h3>API</h3>
    <p>
        API-osio sisältää reititysmääritykset, jotka alustetaan sovelluksen käynnistyessä. Nämä reitit palvelevat kaikkia API-asiakkaita.
         <pre><code class="language-csharp">
public static partial class Routes
{
    public static void MapRoutes(this WebApplication app)
    {
        app.MapPost('/' + APICalls.DeviceLogIn, (Services services,Request request) =>
        {
            return services.DeviceLoginAsync(request);
        });
        app.MapPost('/' + APICalls.StampcategoryNames, (Services services, Request request) =>
        {
            return services.StampcategoryNamesAsync(request);
        });
        app.MapPost('/' + APICalls.SaveStampAsync, (Services services, StampingRequest request) =>
        {
            return services.SaveStampAsync(request);
        });

        app.MapGet("/download/timestamp.apk", () =>
        {
            var apkFolder = Path.Combine(app.Environment.ContentRootPath, "PrivateFiles");
            var safeName = Path.GetFileName("fi.aikaleima.timestamp.apk");
            var filePath = Path.Combine(apkFolder, safeName);

            if (!File.Exists(filePath)) return Results.NotFound();

            var stream = File.OpenRead(filePath);

            return Results.File(stream,
                                contentType: "application/vnd.android.package-archive",
                                fileDownloadName: safeName,
                                enableRangeProcessing: true);
        });
        app.MapPost('/' + APICalls.UserLogIn, (Services services, Request request) =>
        {
            return services.LoginAsync(request);
        });
        app.MapPost('/' + APICalls.Stamps, (Services services, Request request) =>
        {
            return services.StampsAsync(request);
        });

    }
}
        </code></pre>
    </p>

</article>
<script>
    document.addEventListener('DOMContentLoaded', function () {
        // Käsittele kaikki koodilohkot, jotka tarvitsevat HTML-merkkien muunnon
        document.querySelectorAll('.escape-needed').forEach(block => {
            // Etsi kommentti elementin sisältä (Razor-koodia varten)
            const commentNode = Array.from(block.childNodes).find(node => node.nodeType === Node.COMMENT_NODE);

            if (commentNode) {
                const rawCode = commentNode.textContent; // Käytä kommentin sisältöä
                // Aseta koodi tekstinä, jotta selain ei tulkitse sitä HTML:nä
                // ja Prism voi korostaa sen oikein.
                block.textContent = rawCode;
            }
        });

        // Pyydetään Prismia korostamaan kaikki koodilohkot sivulla
        Prism.highlightAll();
    });
</script>
</body>
</html>